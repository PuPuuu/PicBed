
> 参考自：https://www.jianshu.com/p/bb33282402d7

## 功能

- **管理硬件**（如设备驱动：实现用户提出的I/O操做需求，完成数据的输入输出）

- **管理内存**：物理内存/虚拟内存
- **处理中断**

## 内核特征

- **并发**：一段时间内多个程序执行
- **共享**：“同时”访问，互斥共享
- **虚拟**：硬件虚拟化（CPU->进程，磁盘->文件，内存->地址）
- **异步**：程序走走停停，但结果一致

## BIOS：基本I/O处理系统

- 早期的BIOS存储在**ROM**中，大小不超过64KB；目前大多1MB到2MB，被存储在**闪存**中

> ROM是只读存储器，只能读取、复制等；闪存是断电以后不丢失数据的存储器，不能以字节的方式擦拭信息，只能以区域/块的方式擦除

- **POST**（**Power-On Self-Test**）：加电自检，主要是对CPU、内存等硬件设备进行检测和初始化，执行BIOS
- **主引导记录**：**BIOS按照"启动顺序"**，把控制权转交给排在第一位的储存设备，**将BootLoader从磁盘的引导扇区加载到内存的0x7c00处**；**跳转到CS：IP = 0000:7c00处开始执行BootLoader**

> CS为**代码段寄存器**，IP为**指令指针寄存器**，任意时刻，**CPU将CS:IP指向的内容当作指令执行**。
>  在8086系统中，访问存储器的地址码由**段地址**(CS)和**段内偏移地址**(IP)两部分组成**段寄存器**用来存放各分段的逻辑基值。

### BootLoader：加载OS

- 存放在硬盘第一额引导扇区，512字节
- 将操作系统的代码和数据从硬盘加载到内存
- 跳转到操作系统的起始地址

## 中断、异常、系统调用

### 操作系统的交互

- 面向外设：中断和I/O
- 面向应用程序：异常和系统调用

### 中断（源于外设）：来自不同的硬件设备的计时器和网络的中断

- 引入中断技术初衷是**提高多道程序运行环境中CPU的利用率**，主要**针对外部设备**。**现代操作系统是靠中断驱动的软件**。

#### 特点

- 异步
- **对用户应用程序透明，用户感知不到中断**
- 常见中断类型：**程序中断，时钟中断，I/O中断，硬件中断**

#### 相关术语

- **中断源：引发中断的事件**
- **中断请求：中断源向CPU发出的请求中断处理信号**

- **中断响应**：**CPU收到中断请求后转去执行相应的事件处理程序**

- **中断屏蔽**：在中断请求产生后，**系统用软件方式有选择的封锁中断，而允许其他中断仍能得到响应**

- **关中断**：又称**禁止中断**，**CPU内部处理机状态字（PSW）中断允许位被清除，不允许CPU响应中断**

- **开中断**：**与关中断相反，CPU内部处理机状态字（PSW）中断允许位被恢复，允许CPU响应中断

#### 中断分类

- 硬中断
  - 外中断：来自**CPU外部和内存外部的中断**（如**I/O中断和外部信号中断**，其实就是我们一般上说的，狭义上的中断）
  - **内中断**：来自**CPU内部和内存内部产生的中断**，也称为**陷入**（**trap**）或者**异常**，（比如常见的**算术溢出，除数为0，地址非法，缺页**等等）
- **软中断**：是一条CPU指令，主要用于**执行系统调用**（**int 0x80汇编指令**）以及给调试程序通报一个特定的事件，属于**同步中断**

> 所有的**硬中断的优先级都高于软中断**

#### 中断处理过程

- 硬件：设置中断标记[CPU初始化]
  - 将内部、外部事件设置中断标记
  - 生成中断事件的ID
- 软件
  - 保存当前处理状态[保护现场]
  - 中断服务程序处理(中断向量表)[中断服务]
  - 清除中断标记[恢复现场]
  - 恢复之前保存的状态[中断返回]

##### 中断向量和中断向量表

- **中断向量**：Intel x86系列微机共支持**256种向量中断**，为**使处理器较容易地识别每种中断源**，**将它们从0～255 编号，即赋予一个中断类型码n**，**这个8位的无符号整数叫做一个向量**，也叫**中断向量**
- **中断向量表**：在**实地址模式中**，CPU 把**内存中从0 开始的1K 字节**作为一个**中断向量表**；**表中的每个表项占4个字节**，由两个字节的**段基址**和两个字节的**偏移量**组成，这样构成的地址便是**相应中断处理程序的入口地址**。

### 异常：非法指令或其他坏的处理状态(如内存出错)

#### 特点

- **同步**
- **杀死或重新执行意想不到的的程序指令**（此时操作系统可能支持此指令了）

#### 异常分类

- **故障（Fault）**：如**缺页中断**
- **陷阱（Trap）**：**调用某些系统函数**，如打开文件的时候，触发陷阱，进行系统调用
- **夭折（Abort）**：**发生严重错误，无法恢复运行**

#### 异常处理过程

- 保存现场
- 异常处理
  - 杀死异常程序
  - 重新执行异常指令
- 恢复现场

### 系统调用：应用程序主动向操作系统发出服务请求

#### 特点

- **同步或异步**
- **等待和持续（系统返回数据后继续执行）**

#### 系统调用处理过程

- **应用程序访问高层次API接口而实现**
- **触发用户态到内核态的转换**

> Linux中任何一个用户进程被创建时都包含2个栈：内核栈，用户栈，并且是进程私有的，从用户态开始运行。内核态和用户态分别对应内核空间与用户空间，内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。不管是内核空间还是用户空间，它们都处于虚拟空间中。

#### 系统调用/函数调用的区别

- 函数调用在同一个堆栈内完成
- 系统调用存在用户态栈和内核态栈的切换

## 内存管理

- **内存分层结构**：**金字塔结构**
  1. **CPU寄存器**
  2. **cache**(L1缓存 L2缓存...)
  3. **主存**
  4. **硬盘(虚拟内存)**

> 主存与硬盘之间存在**交换/分页**

### 内存管理目标

- **抽象**：**逻辑地址空间**（应用程序不用考虑底层）
- **保护**：**独立地址空间**（同时运行多个程序，进程进程间隔离）
- **共享**：**访问相同内存**（进程间通信）
- **虚拟化**：**更多的内存空间**

![image-20230612094418796](/Users/yejunjie/hub/notes/assets/image-20230612094418796.png)

> 从低地址到高地址分别内存区分别为：代码段，数据段（初始化），数据段（未初始化）（BSS），堆，栈，命令行参数和环境变量。（**堆向高内存地址生长，栈向低内存地址生长**）

> 代码段：存放**全局常量**（const）、**字符串常量**、**程序代码**
>
> 数据段（初始化）：存放**初始化的全局变量**、**初始化的静态变量**（全局的和局部的）
>
> 数据段（未初始化）（BSS）：存放**未初始化的全局变量**、**未初始化的静态变量**（全局的和局部的）
>
> 堆：存放**动态分配的区域**（malloc、new等）
>
> 栈：存放**局部变量**（初始化以及未初始化的，但不包含静态变量）、**局部常量**（const）
>
> 命令行参数和环境变量：存放命令行参数和环境变量

> - 代码段：存放全局常量（const）、字符串常量、程序代码
>
> - 数据段（初始化）：存放初始化的全局变量、初始化的静态变量
> - 数据段（未初始化）（BSS）：存放未初始化的全局变量、未初始化的静态变量
> - 堆：存放动态分配的区域
> - 栈：存放局部变量、局部常量
> - 命令行参数和环境变量：存放命令行参数和环境变量

CPU 上用来做**内存地址转换**的叫做**内存管理单元（MMU）**，其完成**逻辑地址到物理地址的映射**。